# Authentication

Repository: [https://github.com/cmmvio/cmmv/tree/main/packages/auth](https://github.com/cmmvio/cmmv/tree/main/packages/auth)

The ``@cmmv/auth`` module provides a set of features to handle authentication in your application. It supports both HTTP and WebSocket-based authentication and can be easily integrated into any ``@cmmv`` based application.

## Installation

To install the ``@cmmv/auth`` module, run the following command:

```typescript
$ pnpm add @cmmv/auth
```

## Integrating

Once installed, you can integrate the ``@cmmv/auth`` module into your application as shown below. This example demonstrates the basic setup of a CMMV application that includes the ``@cmmv/auth`` module for handling authentication.

```typescript
require('dotenv').config();

import { Application } from '@cmmv/core';
import { ExpressAdapter, ExpressModule } from '@cmmv/http';
import { ProtobufModule } from '@cmmv/protobuf';
import { WSModule, WSAdapter } from '@cmmv/ws';
import { ViewModule } from '@cmmv/view';
...
import { AuthModule } from '@cmmv/auth';

Application.create({
    httpAdapter: ExpressAdapter,
    wsAdapter: WSAdapter,
    modules: [
        ExpressModule,
        ProtobufModule,
        WSModule,
        ViewModule,
        RepositoryModule,
        AuthModule,  // Add the AuthModule
    ],
    services: [
        // Add your custom services here
    ],
    contracts: [
        // Add your contracts here
    ],
});
```

## Configuration

The ``.cmmv.config.cjs`` file is the central configuration file for your CMMV application, which allows you to set up different settings related to the server, authentication, and other modules. Below is a detailed explanation of the configuration options relevant to the ``@cmmv/auth`` module:

```javascript
module.exports = {
    env: process.env.NODE_ENV,

    server: {
        session: {
            enabled: true,  // Enable session support
            options: {
                // Name of the session cookie
                sessionCookieName: "cmmv-session",
                // Secret for signing the session ID cookie
                secret: process.env.SESSION_SECRET,
                // Prevents session being saved back to the session store
                resave: false,
                // Forces a session to be saved, even if it’s uninitialized
                saveUninitialized: false,
                cookie: {
                    // Ensures the browser only sends the cookie over HTTPS
                    secure: true,
                    // The max age (in milliseconds) for the session cookie
                    maxAge: 60000
                }
            }
        }
    },

    // Authentication settings for @cmmv/auth
    auth: {
        // Enable local registration (email/password)
        localRegister: true,
        // Enable local login (email/password)
        localLogin: true,
        // Secret key for signing JWT tokens
        jwtSecret: process.env.JWT_SECRET || "secret",
        // Secret key for signing JWT refresh token
        jwtSecretRefresh: process.env.JWT_SECRET_REFRESH,
        // Name of the refresh token cookie
        refreshCookieName: "refreshToken",
        // Token expiration time in seconds (1 hour)
        expiresIn: 60 * 60,
        qrCode: {} //See QR Code topic
        optSecret: {
            issuer: "CMMV",
            algorithm: "sha512"
        },
        recaptcha: {
            required: true,
            secret: process.env.RECAPTCHA_SECRET
        }
    },
};
```

## Generated

The ``@cmmv/auth`` module is responsible for generating the necessary files for authentication in a CMMV-based application. This includes protocol buffers (proto files), TypeScript definitions, service implementations, and controllers. If the ``@cmmv/ws`` module is installed, it will also generate the WebSocket gateway for handling authentication events. Below are the key components that are generated by this module:

**``.generated/protos/auth/user.proto``**

This ``.proto`` file defines the ``User``, ``LoginRequest``, ``LoginResponse``, ``RegisterRequest``, ``RegisterResponse`` messages, and the ``AuthService`` service with two RPC methods, Login and Register.

```proto
/**
    **********************************************
    This script was generated automatically by CMMV.
    It is recommended not to modify this file manually,
    as it may be overwritten by the application.
    **********************************************
**/

syntax = "proto3";
package auth;

import "./groups.proto";

message User {
   string username = 1;
   string password = 2;
   string provider = 3;
   repeated Groups groups = 4;
   repeated string roles = 5;
   bool root = 6;
   bool blocked = 7;
   bool validated = 8;
   bool verifyEmail = 9;
   int32 verifyEmailCode = 10;
   bool verifySMS = 11;
   int32 verifySMSCode = 12;
   string optSecret = 13;
   bool optSecretVerify = 14;
}

message UserList {
    repeated User items = 1;
}

message AddUserRequest {
    User item = 1;
}

message AddUserResponse {
    string id = 1;
    User item = 2;
}

message UpdateUserRequest {
    string id = 1;
    User item = 2;
}

message UpdateUserResponse {
    bool success = 1;
    int32 affected = 2;
}

message DeleteUserRequest {
    string id = 1;
}

message DeleteUserResponse {
    bool success = 1;
    int32 affected = 2;
}

message GetAllUserRequest {}

message GetAllUserResponse {
    UserList items = 1;
}

message LoginRequest {
   string username = 1;
   string password = 2;
}

message LoginResponse {
   bool success = 1;
   optional string token = 2;
   optional string message = 3;
}

message RegisterRequest {
   string username = 1;
   string email = 2;
   string password = 3;
}

message RegisterResponse {
   bool success = 1;
   optional string message = 2;
}

service UserService {
   rpc AddUser (AddUserRequest) returns (AddUserResponse);
   rpc UpdateUser (UpdateUserRequest) returns (UpdateUserResponse);
   rpc DeleteUser (DeleteUserRequest) returns (DeleteUserResponse);
   rpc GetAllUser (GetAllUserRequest) returns (GetAllUserResponse);
   rpc Login (LoginRequest) returns (LoginResponse);
   rpc Register (RegisterRequest) returns (RegisterResponse);
}
```

<br/>

**``.generated/protos/auth/auth.d.ts``**

This file provides TypeScript interfaces that mirror the ``.proto`` definitions, making it easier to work with the data structures in your application.

```typescript
/**
    **********************************************
    This script was generated automatically by CMMV.
    It is recommended not to modify this file manually,
    as it may be overwritten by the application.
    **********************************************
**/

import { Groups } from "./groups.d";

export namespace User {
    export type username = string;
    export type password = string;
    export type provider = string;
    export type groups = Groups;
    export type roles = string;
    export type root = boolean;
    export type blocked = boolean;
    export type validated = boolean;
    export type verifyEmail = boolean;
    export type verifyEmailCode = number;
    export type verifySMS = boolean;
    export type verifySMSCode = number;
    export type optSecret = string;
    export type optSecretVerify = boolean;
}

export interface AddUserRequest {
    item: User;
}

export interface AddUserResponse {
    item: User;
}

export interface UpdateUserRequest {
    id: string;
    item: User;
}

export interface UpdateUserResponse {
    success: boolean;
    affected: number;
}

export interface DeleteUserRequest {
    id: string;
}

export interface DeleteUserResponse {
    success: boolean;
    affected: number;
}

export interface GetAllUserRequest {}

export interface GetAllUserResponse {
    items: User[];
}
```

<br/>

## Decorator

The ``@Auth`` decorator is designed to enforce authentication and authorization on specific routes within an application. It provides middleware functionality that checks if a user is authenticated by verifying a JWT (JSON Web Token) and optionally validates that the user has the required roles to access the route.

This decorator is used in conjunction with route handlers to protect specific endpoints. It validates the existence of a JWT token and, if provided, checks whether the token's payload includes the necessary roles to access the route.

* **Token Location:** The middleware first checks for the JWT token in the request cookies (using a configurable cookie name) or in the ``Authorization`` header. If no token is found, it returns a ``401 Unauthorized`` response.
* **Token Verification:** If a token is found, it verifies the token using the secret stored in the configuration (``auth.jwtSecret``). If the token is invalid or expired, the middleware returns a ``401 Unauthorized`` response.
* **Role Validation:** If roles are specified, the middleware checks if the token's payload includes the required roles. If the user does not have the appropriate roles, the middleware returns a ``403 Forbidden`` response.
* **User Information:** Upon successful validation, the decoded token (which typically includes user information such as user ID, username, and roles) is attached to the ``req.user`` object for further use in the route handler.

```typescript
import { Controller, Get, Req } from '@cmmv/http';
import { Auth } from '@cmmv/auth';

@Controller('user')
export class UserController {
    // Protects the route, checks for valid JWT
    @Get('profile')
    @Auth()
    async getProfile(@Req() req) {
        return req.user;  // Access the authenticated user's info
    }

    // Protects the route, checks for valid JWT and admin role
    @Get('admin')
    @Auth(['admin'])
    async getAdminDashboard(@Req() req) {
        return `Welcome admin ${req.user.username}`;
    }
}
```

<br/>

* **roles?:** (Optional) An array of roles that a user must have to access the route. If no roles are provided, only authentication is required (i.e., a valid JWT). If roles are specified, the user must possess at least one of the provided roles.

```typescript
@Auth(['admin', 'moderator'])
```

**Configuration Dependencies**

* **JWT Secret:** The decorator uses the secret specified in the configuration (``auth.jwtSecret``) to verify the token.
* **Session Cookie Name:** By default, the token is checked in a cookie with the name specified in ``server.session.options.sessionCookieName``. If no token is found in the cookie, it checks the ``Authorization`` header.

The decorator adds the authentication and authorization middleware to the route's metadata. This middleware is processed before the route handler is executed, ensuring that unauthorized users are blocked before any business logic is reached.

# User Registration

Starting from version `0.8.10`, the `@cmmv/auth` module has been redesigned to include controllers, services, and gateways within the module itself, eliminating the need for code generation. Simply adding the module to your application automatically enables all authentication functionalities.

User registration and local login must be explicitly enabled in the configuration file (`.cmmv.config.cjs`) using the `auth.localRegister` and `auth.localLogin` options. If these parameters are disabled, only authentication via external providers will be available.

Endpoint: `/auth/register`
Method: `POST`
Payload Format:

```typescript
{
    username: string;
    password: string;
}
```

Admin-mode registration

```typescript
{
    username: string;
    password: string;
    provider?: string;
    groups?: object | string | string[] | ObjectId;
    roles?: string[];
    root: boolean;
    blocked: boolean;
    validated: boolean;
    verifyEmail: boolean;
    verifyEmailCode?: number;
    verifySMS: boolean;
    verifySMSCode?: number;
    optSecret?: string;
    optSecretVerify: boolean;
    profile?: string;
}
```

## Login

Endpoint: `/auth/login`
Method: `POST`
Payload Format:

```typescript
{
    username: string;
    password: string;
    token?: string;
    opt?: string;
}
```
<br/>

* `token:` Required if reCAPTCHA validation is enabled (`auth.recaptcha.required = true`).
* `opt:` A security code generated by Google Authenticator or a similar service, if Two-Factor Authentication (2FA) is enabled for the user.

Response Format:

```typescript
{
    "status": 200,
    "processingTime": 13,
    "result": {
        "success": true,
        "token": "eyJhbGciOiJIUzI1NiI...",
        "refreshToken": "eyJhbGciOiJIUzI1...",
        "message": "Login successful"
        "actions": "opt-validate"
    }
}
```

### Access Token

The `token` field contains the authentication token, which is valid for 15 minutes.

* This token must be included in the `Authorization` header (`Authorization: Bearer <token>`) for all API requests that require authentication.
* If the token expires, a new one must be obtained using the refresh token.

### Refresh Token

The `refreshToken` is used to renew the access token without requiring the user to log in again.

To refresh an expired token, send a request to:

Endpoint: `/auth/refresh`
Method: `POST`
Headers: `Authorization: Bearer <expired_access_token>`

Normally, browsers automatically send the refresh token via cookies. However, if cookies are not used due to application settings, the refresh token can be sent manually via the `RefreshToken` header:

Headers (alternative method):

```text
Authorization: Bearer <expired_access_token>
RefreshToken: <refresh_token>
```

If the refresh token is valid and was created by the same device that performed the login, the API will return a new access token with a 15-minute validity.

If you attempt to use the access token or refresh token from a tool like Postman and then try to use the refreshed token in a browser or another device, the request will be denied.

The authentication system binds the session to the device and considers the User-Agent of the request, ensuring enhanced security against token theft and session hijacking.

## reCAPTCHA

If reCAPTCHA validation is enabled (`auth.recaptcha.required`), Google’s reCAPTCHA API will be used for verification.

The `secret` key should be stored in the `.env` file and set in `auth.recaptcha.secret`:

```env
RECAPTCHA_SECRET=your-secret-key
```

More details and key generation can be found at: [Google reCAPTCHA Admin](https://www.google.com/recaptcha/admin/create)

## Two-Factor (2FA)

If a user has Two-Factor Authentication (2FA) (`optSecret`) enabled, they must provide a verification code generated by an authenticator app (e.g., Google Authenticator) during login.

To make 2FA mandatory for all users, enable `auth.optSecret.required` in the configuration file.

### QR Code

If the login response indicates that 2FA registration is required, you can request a QR code for scanning via an authentication app using the following endpoint:

Endpoint: `/auth/opt-qrcode`
Method: `GET`
Headers: `Authorization: Bearer <login_token>`
Response: A Base64-encoded QR code image, which can be directly displayed in an IMG tag.

### Activating 2FA for a User

To enable Two-Factor Authentication for a user:

Endpoint: `/auth/opt-enable`
Method: `POST`
Headers: `Authorization: Bearer <login_token>`
Payload:

```typescript
{
    "secret": "user-generated-code", // Code generated by the authenticator app
    "token": "optional-recaptcha-token" // Required if reCAPTCHA is enabled
}
```

If the activation is successful, a verification code will be required for future logins on unregistered devices. If the device is already validated, the code will not be necessary.

### Validating 2FA for a New Session

To validate a new session using 2FA:

Endpoint: `/auth/opt-validate`
Method: `POST`
Headers: `Authorization: Bearer <login_token>`
Payload:

```typescript
{
    "secret": "user-generated-code", // Code generated by the authenticator app
    "token": "optional-recaptcha-token" // Required if reCAPTCHA is enabled
}
```

### Disabling 2FA for a User

If a user wants to disable Two-Factor Authentication, they can make a request to:

Endpoint: `/auth/opt-remove`
Method: `DELETE`
Headers: `Authorization: Bearer <login_token>`

## Security Recommendations

The authentication module is designed as a foundational component for the CMMV IAM System, which will be developed soon. If you choose to manage session control independently, we strongly recommend following these best security practices:

### Secure Transmission (HTTPS)
<br/>

* Always use HTTPS for both registration and login requests.
* This prevents Man-in-the-Middle (MitM) attacks, ensuring that credentials and tokens are encrypted during transmission.

### Implement reCAPTCHA Protection
<br/>

* Obtain free reCAPTCHA keys and register them in the system.
* Enable reCAPTCHA validation for login and registration by setting
* This helps mitigate automated brute-force attacks.

### Secure JWT Key Management

Use separate and strongly generated keys for `jwtSecret` and `jwtSecretRefresh`

```text
JWT_SECRET=secure_random_key_1
JWT_SECRET_REFRESH=secure_random_key_2
```
<br/>

* DO NOT use the same key for both authentication and refresh tokens.
* Store these keys securely in the `.env` file and ensure different keys for development and production environments.

### Enforce Two-Factor Authentication (2FA)
<br/>

* Strongly recommend making 2FA mandatory for all users
* This adds an extra layer of security, preventing unauthorized access even if a password is compromised.
* Users will need to verify logins with Google Authenticator or a similar app.

### Future IAM System Integration
<br/>

* Once the CMMV IAM System is released, it is highly recommended to switch to its centralized authentication service.
* You will be able to generate application API keys from [CMMV.io](https://cmmv.io), ensuring a fully managed, secure, and scalable IAM solution.

By implementing these security measures, your authentication system will be significantly more resilient to attacks and aligned with industry best practices.

### Use Strong Password Policies
<br/>

* Enforce minimum password length (e.g., at least 12 characters).
* Require a combination of uppercase, lowercase, numbers, and special characters.
* Prevent the use of common passwords by checking against a breached-password database (e.g., Have I Been Pwned).
* Use rate limiting to prevent brute-force attacks on login attempts.

### Implement Account Lockout

If multiple failed login attempts occur in a short time:

* Temporarily lock the account.
* Require reCAPTCHA verification before allowing further login attempts.
* Send a security notification to the user’s email.
